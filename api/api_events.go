/*
DCSA OpenAPI specification for Track & Trace

Provides equipment actual milestones along with Estimated Time of Arrival following DCSA standards

API version: 2.2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type EventsApi interface {

	/*
		GetEvents Find events.

		Find events by Carrier BookingReference, Transport DocumentReference (Bill of lading) or Equipment Reference.The endpoint **requires** only 1 of the 3 query parameters to be used.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetEventsRequest
	*/
	GetEvents(ctx context.Context) ApiGetEventsRequest

	// GetEventsExecute executes the request
	//  @return []EventsInner
	GetEventsExecute(r ApiGetEventsRequest) ([]EventsInner, *http.Response, error)
}

// EventsApiService EventsApi service
type EventsApiService service

type ApiGetEventsRequest struct {
	ctx                        context.Context
	ApiService                 EventsApi
	carrierBookingReference    *string
	transportDocumentReference *string
	equipmentReference         *string
}

// A set of unique characters provided by carrier to identify a booking.  Specifying this filter will only return events related to this particular carrierBookingReference.
func (r ApiGetEventsRequest) CarrierBookingReference(carrierBookingReference string) ApiGetEventsRequest {
	r.carrierBookingReference = &carrierBookingReference
	return r
}

// A unique number reference allocated by the shipping line to the transport document and the main number used for the tracking of the status of the shipment.  Specifying this filter will only return events related to this particular transportDocumentReference
func (r ApiGetEventsRequest) TransportDocumentReference(transportDocumentReference string) ApiGetEventsRequest {
	r.transportDocumentReference = &transportDocumentReference
	return r
}

// Will filter by the unique identifier for the equipment, which should follow the BIC ISO Container Identification Number where possible.  Specifying this filter will only return events related to this particular equipmentReference
func (r ApiGetEventsRequest) EquipmentReference(equipmentReference string) ApiGetEventsRequest {
	r.equipmentReference = &equipmentReference
	return r
}

func (r ApiGetEventsRequest) Execute() ([]EventsInner, *http.Response, error) {
	return r.ApiService.GetEventsExecute(r)
}

/*
GetEvents Find events.

Find events by Carrier BookingReference, Transport DocumentReference (Bill of lading) or Equipment Reference.The endpoint **requires** only 1 of the 3 query parameters to be used.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEventsRequest
*/
func (a *EventsApiService) GetEvents(ctx context.Context) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []EventsInner
func (a *EventsApiService) GetEventsExecute(r ApiGetEventsRequest) ([]EventsInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []EventsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.GetEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2.2/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrierBookingReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrierBookingReference", r.carrierBookingReference, "")
	}
	if r.transportDocumentReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transportDocumentReference", r.transportDocumentReference, "")
	}
	if r.equipmentReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "equipmentReference", r.equipmentReference, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v InlineResponseDefault
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
